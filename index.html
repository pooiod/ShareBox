<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShareBox Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <style>
        :root { 
            --border-color: #ddd; 
            --hover-bg: #e5f3ff; 
            --selected-bg: #cce8ff; 
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --background-color: #f8f9fa;
            --text-color: #333;
            --input-bg: #fff;
            --input-border: #ccc;
        }
        html, body { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Arial, sans-serif; font-size: 14px; overflow: hidden; color: var(--text-color); background-color: var(--background-color); }
        .explorer-window { display: flex; flex-direction: column; height: 100vh; background-color: white; }
        .ribbon { display: flex; align-items: center; padding: 4px 10px; border-bottom: 1px solid var(--border-color); background-color: #f5f5f5; flex-shrink: 0; gap: 10px; }
        .ribbon-group { display: flex; align-items: center; padding: 0 5px; gap: 5px; }
        .ribbon-group:last-child { border-right: none; margin-left: auto; }
        .ribbon-group button { display: flex; flex-direction: column; align-items: center; background: none; border: 1px solid transparent; padding: 5px; cursor: pointer; font-size: 12px; border-radius: 3px; }
        .ribbon-group button:hover { background-color: var(--hover-bg); border-color: #aadeff; }
        .ribbon-group button svg { width: 24px; height: 24px; margin-bottom: 3px; }
        .main-body { flex-grow: 1; overflow: hidden; display: flex; }
        .content-pane { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        .address-bar { display: flex; align-items: center; padding: 5px; border-bottom: 1px solid var(--border-color); }
        .address-bar-path { flex-grow: 1; background-color: white; border: 1px solid var(--border-color); padding: 4px 8px; margin: 0 5px; border-radius: 3px; }
        .file-view { flex-grow: 1; overflow-y: auto; }
        .file-table { width: 100%; border-collapse: collapse; }
        .file-table th { text-align: left; padding: 8px 12px; border-bottom: 2px solid var(--border-color); background-color: #f9f9f9; font-weight: 600; }
        .file-table td { padding: 5px 12px; border-bottom: 1px solid #f0f0f0; }
        .file-table tr { cursor: pointer; user-select: none; }
        .file-table tr:hover { background-color: var(--hover-bg); }
        .file-table .item-name-cell { display: flex; align-items: center; }
        .file-table .item-name-cell svg, .file-table .item-name-cell img { width: 20px; height: 20px; margin-right: 10px; flex-shrink: 0; }
        .file-table .item-name-cell input { width: 100%; border: 1px solid #007bff; padding: 2px 5px; font-family: inherit; font-size: inherit; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 25px; border-radius: 8px; width: 400px; box-sizing: border-box; }
        .modal-content h2 { margin-top: 0; }
        #node-list, #upload-node-list, #change-node-list { max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); margin: 10px 0; padding: 5px; }
        #node-list label, #upload-node-list label, #change-node-list label { display: block; padding: 5px; user-select: none; cursor: pointer; border-radius: 3px; }
        #upload-node-list label:hover, #change-node-list label:hover { background-color: var(--hover-bg); }
        #properties-modal pre { white-space: pre-wrap; background-color: #f5f5f5; padding: 15px; border-radius: 4px; }
        #context-menu { position: fixed; z-index: 2000; background: white; border: 1px solid #ccc; border-radius: 4px; padding: 5px 0; min-width: 150px; }
        #context-menu div { padding: 8px 15px; cursor: pointer; }
        #context-menu div:hover { background-color: var(--hover-bg); }
        #media-viewer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.85); z-index: 3000; display: none; justify-content: center; align-items: center; flex-direction: column; }
        #image-box { max-width: 90vw; max-height: 80vh; overflow: hidden; background-color: white; background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0; border: 3px solid white; border-radius: 5px; }
        #media-viewer img { cursor: grab; max-width: initial; max-height: initial; transform-origin: center center; transition: transform 0.2s ease-out; user-select: none; }
        #media-viewer video { max-width: 90vw; max-height: 80vh; border: 3px solid white; border-radius: 5px; }
        #media-viewer audio { max-width: 90vw; border: 3px solid white; border-radius: 25px; }
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.85); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; font-size: 1.5em; color: #333; text-align: center; }
        #progress-container { width: 80%; max-width: 400px; height: 20px; background-color: #e0e0e0; border-radius: 10px; overflow: hidden; margin-top: 20px; display: none; border: 1px solid #ccc; }
        #progress-bar { width: 0%; height: 100%; background-color: #007bff; transition: width 0.2s ease-in-out; }
        #notification-popup { position: fixed; bottom: 20px; right: 20px; background-color: #fff; border: 1px solid #ccc; border-radius: 5px; padding: 15px; z-index: 5000; display: none; max-width: 300px; }
        .login-container { display: flex; justify-content: center; align-items: center; height: 100%; background-color: var(--background-color); }
        .login-box { background: var(--input-bg); padding: 40px; border-radius: 8px; text-align: center; width: 350px; }
        .login-box h2 { margin-top: 0; margin-bottom: 25px; font-size: 24px; color: var(--text-color); }
        .login-box input[type="text"], .login-box input[type="password"] { width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid var(--input-border); border-radius: 4px; box-sizing: border-box; font-size: 16px; }
        .login-box button { width: 100%; padding: 12px; border: none; border-radius: 4px; background-color: var(--primary-color); color: white; font-size: 16px; cursor: pointer; margin-bottom: 10px; transition: background-color 0.2s ease; }
        .login-box button:hover { background-color: var(--primary-hover); }
        .login-box button.secondary { background-color: #6c757d; }
        .login-box button.secondary:hover { background-color: #5a6268; }
        .node-selection-box { margin-top: 20px; text-align: left; }
        .node-selection-box p { margin-top: 0; margin-bottom: 10px; font-weight: bold; }
        #node-list { background-color: #f1f1f1; border-radius: 4px; }
        .modal-content p { margin: 15px 0; line-height: 1.5; }
        .modal-content input[type="text"] { width: 100%; padding: 10px; margin-top: 5px; margin-bottom: 20px; border: 1px solid var(--input-border); border-radius: 4px; box-sizing: border-box; font-size: 14px; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }
        .modal-buttons button { padding: 8px 20px; border: none; border-radius: 4px; background-color: var(--primary-color); color: white; font-size: 14px; cursor: pointer; transition: background-color 0.2s ease; }
        .modal-buttons button:hover { background-color: var(--primary-hover); }
        .modal-buttons button.secondary { background-color: #6c757d; }
        .modal-buttons button.secondary:hover { background-color: #5a6268; }
        .media-controls button { padding: 8px 15px; border: 1px solid transparent; border-radius: 4px; background-color: #fff; cursor: pointer; border-color: #ccc; transition: background-color 0.2s, border-color 0.2s; }
        .media-controls button:hover { background-color: #f0f0f0; border-color: #bbb; }
        #notification-popup p { margin: 0 0 15px 0; }
        #notification-popup .modal-buttons button { font-size: 12px; padding: 5px 15px; }
    </style>
</head>
<body>
    <div id="connection-modal" class="login-container" style="display:none;">
        <div class="login-box">
            <h2 id="connection-title">Connect to ShareBox Group</h2>
            <div id="group-id-container"><input type="password" id="groupIdInput" placeholder="Group ID"></div>
            <button id="fetchNodesBtn">Find Nodes</button>
            <button class="secondary" onclick="window.location.href='/download'">Create a Node</button>
            <div id="node-selection" style="display:none;" class="node-selection-box">
                <p>Select nodes to connect to:</p>
                <div id="node-list"></div>
                <button id="connectBtn">Connect</button>
            </div>
        </div>
    </div>

    <div id="change-nodes-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Manage Active Nodes</h2>
            <p>Select the nodes you want to be connected to.</p>
            <div id="change-node-list"></div>
            <div class="modal-buttons">
                <button id="saveNodeChangesBtn">Update Connection</button>
                <button class="secondary" onclick="document.getElementById('change-nodes-modal').style.display='none'">Cancel</button>
            </div>
        </div>
    </div>

    <div id="upload-target-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Select Upload Target</h2>
            <p>Choose a single node to upload the file(s) to.</p>
            <div id="upload-node-list"></div>
            <div class="modal-buttons">
                <button id="confirmUploadTargetBtn">Select & Upload</button>
                <button class="secondary" onclick="document.getElementById('upload-target-modal').style.display = 'none'">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="properties-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Properties</h2>
            <pre id="properties-content"></pre>
            <div class="modal-buttons">
                <button id="properties-close-btn">Close</button>
            </div>
        </div>
    </div>

    <div id="custom-alert-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Alert</h2>
            <p id="custom-alert-message"></p>
            <div class="modal-buttons">
                <button id="custom-alert-ok-btn">OK</button>
            </div>
        </div>
    </div>

    <div id="custom-confirm-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Confirmation</h2>
            <p id="custom-confirm-message"></p>
            <div class="modal-buttons">
                <button id="custom-confirm-yes-btn">Yes</button>
                <button id="custom-confirm-no-btn" class="secondary">No</button>
            </div>
        </div>
    </div>

    <div id="custom-prompt-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Input Required</h2>
            <p id="custom-prompt-message"></p>
            <input type="text" id="custom-prompt-input">
            <div class="modal-buttons">
                <button id="custom-prompt-ok-btn">OK</button>
                <button id="custom-prompt-cancel-btn" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="explorer-window" style="display:none;">
        <header class="ribbon">
            <div class="ribbon-group">
                <button id="uploadBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z" /></svg>Upload</button>
                <button id="uploadFolderBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M10 4H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8c0-1.11-.89-2-2-2h-8l-2-2m4.5 10.5l-3.5-3.5h2.5V9h2v2h2.5l-3.5 3.5Z"/></svg>Upload Folder</button>
                <button id="newFolderBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4M19,13H17V15H15V13H13V11H15V9H17V11H19V13Z"/></svg>New Folder</button>
                <button id="reloadBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg>Reload</button>
            </div>
            <div class="ribbon-group">
                <button id="changeNodesBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L16.04,7.15C16.56,7.62 17.24,7.92 18,7.92C19.66,7.92 21,6.58 21,5C21,3.42 19.66,2 18,2C16.34,2 15,3.42 15,5C15,5.24 15.04,5.47 15.09,5.7L7.96,9.85C7.44,9.38 6.76,9.08 6,9.08C4.34,9.08 3,10.42 3,12C3,13.58 4.34,14.92 6,14.92C6.76,14.92 7.44,14.62 7.96,14.15L15.09,18.3C15.04,18.53 15,18.76 15,19C15,20.58 16.34,21.92 18,21.92C19.66,21.92 21,20.58 21,19C21,17.42 19.66,16.08 18,16.08Z" /></svg>Change Nodes</button>
                <button id="logoutBtn"><svg viewBox="0 0 24 24"><path fill="currentColor" d="M16,17V14H9V10H16V7L21,12L16,17M14,2A2,2 0 0,1 16,4V6H14V4H5V20H14V18H16V20A2,2 0 0,1 14,22H5A2,2 0 0,1 3,20V4A2,2 0 0,1 5,2H14Z" /></svg>Logout</button>
            </div>
        </header>
        <main class="main-body">
            <div class="content-pane">
                <div class="address-bar"><span id="current-path-display" class="address-bar-path">/</span></div>
                <div class="file-view"><table class="file-table"><thead><tr><th>Name</th><th>Type</th></tr></thead><tbody id="file-list-body"></tbody></table></div>
            </div>
        </main>
    </div>

    <div id="context-menu" style="display:none;"></div>
    <div id="media-viewer"><div id="media-content"></div><div class="media-controls"></div></div>
    <div id="loader" style="display:none;"><span id="loader-text"></span><div id="progress-container"><div id="progress-bar"></div></div></div>
    <div id="notification-popup">
        <p id="notification-message"></p>
        <div class="modal-buttons">
            <button id="notification-yes">Yes</button>
            <button id="notification-no" class="secondary">No</button>
        </div>
    </div>
    <input type="file" id="fileUploader" style="display: none;" multiple>
    <input type="file" id="folderUploader" style="display: none;" webkitdirectory directory multiple>

    <script>
        const MQTT_BROKER = "broker.emqx.io", MQTT_PORT = 8084, UPLOAD_CHUNK_SIZE = 100 * 1024;
        let groupID = "", currentPath = "/", isBusy = false, mqttClient = null, pendingRequests = {}, connectedHosts = new Set(), hostDetails = new Map(), deniedHosts = new Set();
        const ICONS = {
            folder: '<svg viewBox="0 0 24 24"><path fill="#FFCA28" d="M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z" /></svg>',
            file: '<svg viewBox="0 0 24 24"><path fill="#90A4AE" d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2Z" /></svg>',
            up: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z" /></svg>',
            image: '<svg viewBox="0 0 24 24"><path fill="#4CAF50" d="M21,19V5C21,3.89 20.1,3 19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19M8.5,13.5L11,16.5L14.5,12L19,18H5L8.5,13.5Z" /></svg>',
            video: '<svg viewBox="0 0 24 24"><path fill="#F44336" d="M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z" /></svg>',
            archive: '<svg viewBox="0 0 24 24"><path fill="#FF9800" d="M20,6H12L10,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8A2,2 0 0,0 20,6M18,18H16V16H18V18M18,14H16V12H18V14M16,10H14V12H16V14H14V16H12V14H14V12H12V10H14V8H16V10Z" /></svg>',
            audio: '<svg viewBox="0 0 24 24"><path fill="#03A9F4" d="M12,3V13.55C11.41,13.21 10.73,13 10,13A3,3 0 0,0 7,16A3,3 0 0,0 10,19A3,3 0 0,0 13,16V5H18V3H12Z" /></svg>',
            scratch: `<img src="https://cdn2.steamgriddb.com/icon/969a086e0717a9b496dd0e9a50ec8010.png">`,
            penguinmod: `<img src="https://penguinmod.com/favicon.ico">`,
            executable: '<svg viewBox="0 0 24 24"><path fill="#607D8B" d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,8V18H20V8H4M6,10H10V12H6V10Z" /></svg>',
            python: '<svg viewBox="0 0 24 24"><path fill="#306998" d="M14.5,19.94C15.32,20.65 16.42,21 17.5,21C19.43,21 21,19.43 21,17.5C21,15.57 19.43,14 17.5,14C16.31,14 15.28,14.44 14.5,15.19V12H12V14.5C11.42,14.19 10.77,14 10,14C8.07,14 6.5,15.57 6.5,17.5V17.5C6.5,19.43 8.07,21 10,21C11.23,21 12.28,20.47 12.86,19.58L13.5,18.94V19.94H14.5M17.5,15.5A2,2 0 0,1 19.5,17.5A2,2 0 0,1 17.5,19.5A2,2 0 0,1 15.5,17.5A2,2 0 0,1 17.5,15.5M10,15.5A2,2 0 0,1 12,17.5A2,2 0 0,1 10,19.5A2,2 0 0,1 8,17.5A2,2 0 0,1 10,15.5M9.5,4.06C8.68,3.35 7.58,3 6.5,3C4.57,3 3,4.57 3,6.5C3,8.43 4.57,10 6.5,10C7.69,10 8.72,9.56 9.5,8.81V12H12V9.5C12.58,9.81 13.23,10 14,10C15.93,10 17.5,8.43 17.5,6.5V6.5C17.5,4.57 15.93,3 14,3C12.77,3 11.72,3.53 11.14,4.42L10.5,5.06V4.06H9.5M6.5,8.5A2,2 0 0,1 4.5,6.5A2,2 0 0,1 6.5,4.5A2,2 0 0,1 8.5,6.5A2,2 0 0,1 6.5,8.5M14,8.5A2,2 0 0,1 12,6.5A2,2 0 0,1 14,4.5A2,2 0 0,1 16,6.5A2,2 0 0,1 14,8.5Z"/></svg>',
            roblox: '<svg viewBox="0 0 24 24"><path fill="#00A2FF" d="M15.09,3.5L8.91,3.5C5.07,3.5 3.5,5.07 3.5,8.91L3.5,15.09C3.5,18.93 5.07,20.5 8.91,20.5L15.09,20.5C18.93,20.5 20.5,18.93 20.5,15.09L20.5,8.91C20.5,5.07 18.93,3.5 15.09,3.5ZM12.1,16.21L9.12,14.72L11.9,13.28L14.88,11.78L12.1,10.34L9.12,8.85L12.1,7.35L14.88,8.85L11.9,10.29L9.12,11.79L12.1,13.28L14.88,14.78L12.1,16.21Z" /></svg>'
        };
        const VIEWABLE_TYPES = { image: /\.(jpe?g|png|gif|webp|bmp|svg)$/i, video: /\.(mp4|mov|avi|wmv|webm|mpeg|flv|mkv)$/i, audio: /\.(mp3|wav|ogg|flac|m4a)$/i };
        const ui = { modal: document.getElementById('connection-modal'), groupIdInput: document.getElementById('groupIdInput'), fetchNodesBtn: document.getElementById('fetchNodesBtn'), nodeSelection: document.getElementById('node-selection'), nodeList: document.getElementById('node-list'), connectBtn: document.getElementById('connectBtn'), explorerWindow: document.querySelector('.explorer-window'), uploadBtn: document.getElementById('uploadBtn'), fileUploader: document.getElementById('fileUploader'), fileListBody: document.getElementById('file-list-body'), currentPathDisplay: document.getElementById('current-path-display'), contextMenu: document.getElementById('context-menu'), propertiesModal: document.getElementById('properties-modal'), propertiesContent: document.getElementById('properties-content'), propertiesCloseBtn: document.getElementById('properties-close-btn'), mediaViewer: document.getElementById('media-viewer'), mediaContent: document.getElementById('media-content'), mediaControls: document.querySelector('.media-controls'), reloadBtn: document.getElementById('reloadBtn'), changeNodesBtn: document.getElementById('changeNodesBtn'), logoutBtn: document.getElementById('logoutBtn'), loader: document.getElementById('loader'), loaderText: document.getElementById('loader-text'), progressContainer: document.getElementById('progress-container'), progressBar: document.getElementById('progress-bar'), connectionTitle: document.getElementById('connection-title'), groupIdContainer: document.getElementById('group-id-container'), uploadTargetModal: document.getElementById('upload-target-modal'), uploadNodeList: document.getElementById('upload-node-list'), changeNodesModal: document.getElementById('change-nodes-modal'), changeNodeList: document.getElementById('change-node-list'), saveNodeChangesBtn: document.getElementById('saveNodeChangesBtn'), confirmUploadTargetBtn: document.getElementById('confirmUploadTargetBtn'), uploadFolderBtn: document.getElementById('uploadFolderBtn'), folderUploader: document.getElementById('folderUploader'), newFolderBtn: document.getElementById('newFolderBtn'), notificationPopup: document.getElementById('notification-popup'), notificationMessage: document.getElementById('notification-message'), notificationYes: document.getElementById('notification-yes'), notificationNo: document.getElementById('notification-no'), alertModal: document.getElementById('custom-alert-modal'), alertMessage: document.getElementById('custom-alert-message'), alertOkBtn: document.getElementById('custom-alert-ok-btn'), confirmModal: document.getElementById('custom-confirm-modal'), confirmMessage: document.getElementById('custom-confirm-message'), confirmYesBtn: document.getElementById('custom-confirm-yes-btn'), confirmNoBtn: document.getElementById('custom-confirm-no-btn'), promptModal: document.getElementById('custom-prompt-modal'), promptMessage: document.getElementById('custom-prompt-message'), promptInput: document.getElementById('custom-prompt-input'), promptOkBtn: document.getElementById('custom-prompt-ok-btn'), promptCancelBtn: document.getElementById('custom-prompt-cancel-btn') };
        
        function getCookie(name) { const v = `; ${document.cookie}`; const p = v.split(`; ${name}=`); if (p.length === 2) return p.pop().split(';').shift(); }
        function setCookie(name, value, days) { let e = ""; if (days) { const d=new Date(); d.setTime(d.getTime() + (days*24*60*60*1000)); e = "; expires=" + d.toUTCString(); } document.cookie = name + "=" + (value || "")  + e + "; path=/"; }
        function logout() { if (mqttClient && mqttClient.isConnected()) mqttClient.disconnect(); setCookie('sharebox_group_id', '', -1); setCookie('sharebox_connected_hosts', '', -1); location.reload(); }
        
        window.addEventListener('load', () => {
            const savedGroupId = getCookie('sharebox_group_id');
            const savedHosts = getCookie('sharebox_connected_hosts');
            if (savedGroupId && savedHosts) {
                setCookie('sharebox_group_id', savedGroupId, 30);
                setCookie('sharebox_connected_hosts', savedHosts, 30);
                groupID = savedGroupId; connectedHosts = new Set(JSON.parse(savedHosts));
                if (connectedHosts.size > 0) setupMqttConnection(); else showConnectionModal(false);
            } else { showConnectionModal(false); }
        });

        ui.fetchNodesBtn.addEventListener('click', findNodes);
        ui.connectBtn.addEventListener('click', connectToSelectedNodes);
        ui.uploadBtn.addEventListener('click', () => initiateUpload(ui.fileUploader));
        ui.uploadFolderBtn.addEventListener('click', () => initiateUpload(ui.folderUploader));
        ui.newFolderBtn.addEventListener('click', createNewFolder);
        ui.fileUploader.addEventListener('change', (e) => handleUpload(e.target.files, e.target.targetHostId));
        ui.folderUploader.addEventListener('change', (e) => handleUpload(e.target.files, e.target.targetHostId));
        ui.propertiesCloseBtn.addEventListener('click', () => ui.propertiesModal.style.display = 'none');
        ui.reloadBtn.addEventListener('click', () => listDirectoryContents());
        ui.logoutBtn.addEventListener('click', logout);
        ui.changeNodesBtn.addEventListener('click', showChangeNodesModal);
        ui.saveNodeChangesBtn.addEventListener('click', async () => {
            const selected = Array.from(ui.changeNodeList.querySelectorAll('input:checked')).map(input => input.value);
            if (selected.length === 0) return await showAlert("Select at least one node.");
            connectedHosts = new Set(selected);
            setCookie('sharebox_connected_hosts', JSON.stringify(Array.from(connectedHosts)), 30);
            applyNodeChanges();
        });
        window.addEventListener('click', () => ui.contextMenu.style.display = 'none');
        ui.fileListBody.addEventListener('click', (e) => { const r = e.target.closest('tr'); if(r && !r.querySelector('input')) handleItemActivation(r.dataset.type, r.dataset.name); });
        ui.fileListBody.addEventListener('contextmenu', (e) => { e.preventDefault(); const r = e.target.closest('tr'); if(r) showContextMenu(e.clientX, e.clientY, r.dataset.type, r.dataset.name); });
        
        function showAlert(message) { return new Promise(resolve => { ui.alertMessage.textContent = message; ui.alertModal.style.display = 'flex'; ui.alertOkBtn.onclick = () => { ui.alertModal.style.display = 'none'; resolve(); }; }); }
        function showConfirm(message) { return new Promise(resolve => { ui.confirmMessage.textContent = message; ui.confirmModal.style.display = 'flex'; ui.confirmYesBtn.onclick = () => { ui.confirmModal.style.display = 'none'; resolve(true); }; ui.confirmNoBtn.onclick = () => { ui.confirmModal.style.display = 'none'; resolve(false); }; }); }
        function showPrompt(message, defaultValue = '') {
            return new Promise(resolve => {
                ui.promptMessage.textContent = message; ui.promptInput.value = defaultValue; ui.promptModal.style.display = 'flex'; ui.promptInput.focus(); ui.promptInput.select();
                const closeAndResolve = (value) => { ui.promptModal.style.display = 'none'; ui.promptOkBtn.onclick = null; ui.promptCancelBtn.onclick = null; ui.promptInput.onkeydown = null; resolve(value); }
                ui.promptOkBtn.onclick = () => closeAndResolve(ui.promptInput.value);
                ui.promptCancelBtn.onclick = () => closeAndResolve(null);
                ui.promptInput.onkeydown = (e) => { if (e.key === 'Enter') closeAndResolve(ui.promptInput.value); if (e.key === 'Escape') closeAndResolve(null); };
            });
        }

        function showConnectionModal(isChanging) {
            ui.explorerWindow.style.display = 'none'; ui.modal.style.display = 'flex'; ui.nodeSelection.style.display = 'none';
            if (isChanging) { ui.connectionTitle.textContent = "Change Node Selection"; ui.groupIdContainer.style.display = 'none'; findNodes(); } 
            else { ui.connectionTitle.textContent = "Connect to ShareBox Group"; ui.groupIdContainer.style.display = 'block'; ui.groupIdInput.value = groupID; }
        }

        function showChangeNodesModal() {
            ui.changeNodesModal.style.display = 'flex'; ui.changeNodeList.innerHTML = "<i>Scanning for active nodes...</i>"; ui.saveNodeChangesBtn.disabled = true;
            const foundHosts = new Map();
            const tempClient = new Paho.MQTT.Client(MQTT_BROKER, MQTT_PORT, `finder-change-${Date.now()}`);
            tempClient.onMessageArrived = (msg) => {
                try {
                    const { hostId, hostname } = JSON.parse(msg.payloadString);
                    if (hostId && !foundHosts.has(hostId)) {
                        if (foundHosts.size === 0) ui.changeNodeList.innerHTML = "";
                        foundHosts.set(hostId, hostname || hostId); hostDetails.set(hostId, hostname || hostId);
                        const isChecked = connectedHosts.has(hostId) ? 'checked' : '';
                        ui.changeNodeList.insertAdjacentHTML('beforeend', `<label><input type="checkbox" value="${hostId}" ${isChecked}> ${hostname || hostId}</label>`);
                    }
                } catch (e) {}
            };
            tempClient.connect({ useSSL: true, onSuccess: () => {
                tempClient.subscribe(`sharebox/${groupID}/host/heartbeat`);
                setTimeout(() => {
                    tempClient.disconnect();
                    if (foundHosts.size === 0) { ui.changeNodeList.innerHTML = "<i>No active nodes found in this group.</i>"; } 
                    else { ui.saveNodeChangesBtn.disabled = false; }
                }, 15000); 
            }, onFailure: async (err) => { await showAlert(`MQTT Error: ${err.errorMessage}`); ui.changeNodeList.innerHTML = "<i>Error scanning for nodes.</i>"; } });
        }

        async function findNodes() {
            if (ui.groupIdContainer.style.display !== 'none') { groupID = ui.groupIdInput.value.trim(); if (!groupID) return await showAlert("Group ID required."); }
            ui.fetchNodesBtn.disabled = true; ui.fetchNodesBtn.textContent = "Searching for nodes"; ui.nodeList.innerHTML = "<i>Searching...</i>";
            const foundHosts = new Map();
            const tempClient = new Paho.MQTT.Client(MQTT_BROKER, MQTT_PORT, `finder-${Date.now()}`);
            tempClient.onMessageArrived = (msg) => {
                try {
                    const { hostId, hostname } = JSON.parse(msg.payloadString);
                    if (hostId && !foundHosts.has(hostId)) {
                        if (foundHosts.size === 0) ui.nodeList.innerHTML = "";
                        foundHosts.set(hostId, hostname || hostId); hostDetails.set(hostId, hostname || hostId);
                        const isChecked = (connectedHosts.size === 0 || connectedHosts.has(hostId)) ? 'checked' : 'checked';
                        ui.nodeList.insertAdjacentHTML('beforeend', `<label><input type="checkbox" value="${hostId}" ${isChecked}> ${hostname || hostId}</label>`);
                    }
                } catch (e) {}
            };
            tempClient.connect({ useSSL: true, onSuccess: () => {
                tempClient.subscribe(`sharebox/${groupID}/host/heartbeat`); ui.nodeSelection.style.display = 'block';
                setTimeout(() => {
                    tempClient.disconnect(); ui.fetchNodesBtn.disabled = false; ui.fetchNodesBtn.textContent = "Find Nodes";
                    if (foundHosts.size === 0) ui.nodeList.innerHTML = "<i>No nodes found.</i>";
                }, 20000);
            }, onFailure: async (err) => { await showAlert(`MQTT Error: ${err.errorMessage}`); ui.fetchNodesBtn.disabled = false; } });
        }
        
        async function connectToSelectedNodes() {
            const selected = Array.from(ui.nodeList.querySelectorAll('input:checked')).map(input => input.value);
            if (selected.length === 0) return await showAlert("Select at least one node.");
            connectedHosts = new Set(selected);
            setCookie('sharebox_group_id', groupID, 30); setCookie('sharebox_connected_hosts', JSON.stringify(Array.from(connectedHosts)), 30);
            setupMqttConnection();
        }

        function setupMqttConnection() {
            if (mqttClient && mqttClient.isConnected()) mqttClient.disconnect();
            mqttClient = new Paho.MQTT.Client(MQTT_BROKER, MQTT_PORT, `web-${Date.now()}`);
            mqttClient.onConnectionLost = (res) => { if (res.errorCode !== 0) console.warn(`Connection Lost: ${res.errorMessage}`); logout(); };
            mqttClient.onMessageArrived = (msg) => {
                try {
                    const payload = JSON.parse(msg.payloadString);
                    const { requestID, data, error, sourceHostId, hostId, hostname } = payload;
                    if (requestID && pendingRequests[requestID]) {
                        const promise = pendingRequests[requestID];
                        if (error && !promise.resolved) { promise.reject(new Error(error)); delete pendingRequests[requestID]; } 
                        else if (!error) {
                            if (promise.isAggregating) {
                                promise.results.set(sourceHostId, data);
                                if (promise.results.size >= connectedHosts.size) { clearTimeout(promise.timeout); promise.resolve(promise.results); delete pendingRequests[requestID]; }
                            } else if (!promise.resolved) { promise.resolve(data); promise.resolved = true; clearTimeout(promise.timeout); delete pendingRequests[requestID]; }
                        }
                    } else if (hostId && !hostDetails.has(hostId) && !connectedHosts.has(hostId) && !deniedHosts.has(hostId)) {
                        hostDetails.set(hostId, hostname || hostId); showNewNodeNotification(hostId, hostname || hostId);
                    }
                } catch (e) {}
            };
            mqttClient.connect({ useSSL: true, onSuccess: () => {
                mqttClient.subscribe(`sharebox/${groupID}/host/output`); mqttClient.subscribe(`sharebox/${groupID}/host/heartbeat`);
                ui.modal.style.display = 'none'; ui.explorerWindow.style.display = 'flex';
                currentPath = "/"; updateCurrentPathDisplay(); listDirectoryContents();
            }, onFailure: async (msg) => { await showAlert(`Connection Failed: ${msg.errorMessage}`); logout(); } });
        }
        
        function showNewNodeNotification(hostId, hostname) {
            ui.notificationMessage.textContent = `New node found: "${hostname}". Connect to it?`; ui.notificationPopup.style.display = 'block';
            ui.notificationYes.onclick = () => { connectedHosts.add(hostId); setCookie('sharebox_connected_hosts', JSON.stringify(Array.from(connectedHosts)), 30); listDirectoryContents(); ui.notificationPopup.style.display = 'none'; };
            ui.notificationNo.onclick = () => { deniedHosts.add(hostId); ui.notificationPopup.style.display = 'none'; };
        }

        function runCommand(command, args = [], { targetHostId = null, isAggregating = false, timeout = 20000 } = {}) {
            return new Promise((resolve, reject) => {
                if (!mqttClient || !mqttClient.isConnected()) return reject(new Error("Not connected."));
                const requestID = `req-${Date.now()}-${Math.random()}`;
                const promiseTimeout = setTimeout(() => {
                    const promise = pendingRequests[requestID];
                    if (promise) {
                        if (promise.isAggregating) {
                            const respondedHosts = new Set(promise.results.keys());
                            const timedOutHosts = new Set([...connectedHosts].filter(host => !respondedHosts.has(host)));
                            if (timedOutHosts.size > 0) {
                                const hostNames = Array.from(timedOutHosts).map(id => hostDetails.get(id) || id).join(', ');
                                console.warn(`Nodes disconnected due to no response: ${hostNames}`);
                                connectedHosts = new Set([...connectedHosts].filter(host => !timedOutHosts.has(host)));
                                setCookie('sharebox_connected_hosts', JSON.stringify(Array.from(connectedHosts)), 30);
                            }
                            promise.resolve(promise.results);
                        } else { promise.reject(new Error("Command timed out.")); }
                        delete pendingRequests[requestID];
                    }
                }, timeout);
                const promiseData = { resolve, reject, timeout: promiseTimeout, resolved: false, isAggregating };
                if (isAggregating) promiseData.results = new Map();
                pendingRequests[requestID] = promiseData;
                const payload = { command, args, requestID };
                if (targetHostId) payload.targetHostId = targetHostId;
                const message = new Paho.MQTT.Message(JSON.stringify(payload));
                message.destinationName = `sharebox/${groupID}/client/command`;
                mqttClient.send(message);
            });
        }
        
        async function runCommandWithRetry(command, args = [], options = {}, retries = 3) {
            const finalOptions = { timeout: 5000, ...options };
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    return await runCommand(command, args, finalOptions);
                } catch (error) {
                    console.warn(`Attempt ${attempt} for command '${command}' failed: ${error.message}`);
                    if (attempt === retries) { throw error; }
                }
            }
        }

        async function listDirectoryContents() {
            setBusyState(true, 'Loading...');
            if (connectedHosts.size === 0) { await showAlert("No nodes connected. Please connect to at least one node."); setBusyState(false); return showChangeNodesModal(); }
            try {
                const [folderResults, fileResults] = await Promise.all([
                    runCommand('getfolders', [currentPath], { isAggregating: true, timeout: 10000 }),
                    runCommand('getfiles', [currentPath], { isAggregating: true, timeout: 10000 })
                ]);
                const folderSet = new Set();
                folderResults.forEach(result => (result || "").split('\n').filter(Boolean).forEach(f => folderSet.add(f)));
                const fileSet = new Set();
                fileResults.forEach(result => (result || "").split('\n').filter(Boolean).forEach(f => fileSet.add(f)));
                renderDirectory(Array.from(folderSet).join('\n'), Array.from(fileSet).join('\n'));
            } catch (error) { await showAlert(error.message); }
            finally { setBusyState(false); }
        }

        function getIconForFile(name) {
            if (/\.(sb|sb2|sb3|sprite|sprite2|sprite3)$/i.test(name)) return ICONS.scratch;
            if (/\.pmp$/i.test(name)) return ICONS.penguinmod; if (/\.exe$/i.test(name)) return ICONS.executable; if (/\.py$/i.test(name)) return ICONS.python;
            if (/\.(rbxl|rbxm)$/i.test(name)) return ICONS.roblox; if (VIEWABLE_TYPES.image.test(name)) return ICONS.image; if (VIEWABLE_TYPES.video.test(name)) return ICONS.video;
            if (VIEWABLE_TYPES.audio.test(name)) return ICONS.audio; if (/\.(zip|rar|7z|tar|gz)$/i.test(name)) return ICONS.archive; return ICONS.file;
        }

        function renderDirectory(folderData, fileData) {
            ui.fileListBody.innerHTML = '';
            if (currentPath !== "/") ui.fileListBody.insertAdjacentHTML('beforeend', `<tr data-type="up" data-name=".."><td class="item-name-cell">${ICONS.up} ..</td><td></td></tr>`);
            const folderSet = new Set((folderData || "").split('\n').filter(Boolean));
            folderSet.forEach(name => ui.fileListBody.insertAdjacentHTML('beforeend', `<tr data-type="folder" data-name="${name}"><td class="item-name-cell">${ICONS.folder} ${name}</td><td>File folder</td></tr>`));
            const fileSet = new Set((fileData || "").split('\n').filter(Boolean));
            fileSet.forEach(name => ui.fileListBody.insertAdjacentHTML('beforeend', `<tr data-type="file" data-name="${name}"><td class="item-name-cell">${getIconForFile(name)} ${name}</td><td>File</td></tr>`));
        }

        function handleItemActivation(type, name) {
            if (type === 'up') goUp(); else if (type === 'folder') navigateTo(name);
            else if (type === 'file') { if (VIEWABLE_TYPES.image.test(name) || VIEWABLE_TYPES.video.test(name) || VIEWABLE_TYPES.audio.test(name)) { showMediaViewer(name); } else { handleDownload(name); } }
        }
        
        function showContextMenu(x, y, type, name) {
            if (type === 'up') return;
            ui.contextMenu.innerHTML = ''; let items = ['Rename', 'Properties', 'Delete'];
            if (type === 'file') items.unshift('Download'); if (type === 'folder') items.push('Export');
            items.forEach(item => {
                const div = document.createElement('div'); div.textContent = item;
                div.onclick = () => { if (item === 'Properties') showProperties(name); else if (item === 'Delete') deleteItem(name, type); else if (item === 'Download') handleDownload(name); else if (item === 'Export') handleExport(name); else if (item === 'Rename') handleRename(name); };
                ui.contextMenu.appendChild(div);
            });
            ui.contextMenu.style.left = `${x}px`; ui.contextMenu.style.top = `${y}px`; ui.contextMenu.style.display = 'block';
        }

        async function handleRename(oldName) {
            const row = ui.fileListBody.querySelector(`tr[data-name="${oldName}"]`); if (!row) return;
            const nameCell = row.querySelector('.item-name-cell'); const originalContent = nameCell.innerHTML; const icon = nameCell.querySelector('svg, img').outerHTML;
            nameCell.innerHTML = `${icon} <input type="text" value="${oldName}" />`;
            const input = nameCell.querySelector('input'); input.focus(); input.select();
            const finalize = async () => {
                const newName = input.value.trim(); input.removeEventListener('blur', finalize); input.removeEventListener('keydown', onKeydown);
                if (newName && newName !== oldName && !/[\\/:*?"<>|]/.test(newName)) {
                    try { setBusyState(true, `Renaming to "${newName}"...`); const oldPath = getFullPath(oldName); const newPath = `${newName}`; await runCommand('rename', [oldPath, newPath]); } 
                    catch (e) { await showAlert(`Rename failed: ${e.message}`); } 
                    finally { setBusyState(false); listDirectoryContents(); }
                } else { if (newName !== oldName) await showAlert("Invalid characters in name."); nameCell.innerHTML = originalContent; }
            };
            const onKeydown = (e) => { if (e.key === 'Enter') { input.blur(); } else if (e.key === 'Escape') { input.removeEventListener('blur', finalize); input.removeEventListener('keydown', onKeydown); nameCell.innerHTML = originalContent; } };
            input.addEventListener('blur', finalize); input.addEventListener('keydown', onKeydown);
        }

        async function showProperties(name) {
            try { setBusyState(true, 'Getting properties...'); const props = await runCommand('getproperties', [getFullPath(name)]); ui.propertiesContent.textContent = props; ui.propertiesModal.style.display = 'flex'; } 
            catch(e) { await showAlert(`Could not get properties: ${e.message}`); } finally { setBusyState(false); }
        }

        async function deleteItem(name, type) {
            if (await showConfirm(`Delete this ${type}: "${name}" from all nodes?`)) {
                try { setBusyState(true, `Deleting ${name}...`); await runCommand('delete', [getFullPath(name)]); listDirectoryContents(); } 
                catch(e) { await showAlert(`Could not delete item: ${e.message}`); } finally { setBusyState(false); }
            }
        }
        
        async function fullDownload(fullPath) {
            const numParts = parseInt(await runCommand('downloadlength', [fullPath]), 10);
            if (isNaN(numParts) || numParts <= 0) throw new Error("File empty or unavailable.");
            let allChunks = [];
            for (let i = 1; i <= numParts; i++) {
                setBusyState(true, `Downloading Part ${i} of ${numParts}...`, true); updateProgress(i - 1, numParts);
                const b64Data = await runCommandWithRetry('download', [fullPath, i]);
                const rawBinaryStr = atob(b64Data); const partBytes = new Uint8Array(rawBinaryStr.length);
                for(let j = 0; j < rawBinaryStr.length; j++) partBytes[j] = rawBinaryStr.charCodeAt(j);
                allChunks.push(partBytes);
            }
            updateProgress(1, 1); return new Blob(allChunks);
        }

        async function handleDownload(itemName) {
            try { setBusyState(true, `Preparing download for ${itemName}...`); const blob = await fullDownload(getFullPath(itemName)); triggerBrowserDownload(blob, itemName); } 
            catch(error) { await showAlert(`Download failed: ${error.message}`); } finally { setBusyState(false); }
        }

        async function handleExport(folderName) {
            try { setBusyState(true, `Exporting ${folderName}...`); const blob = await fullDownload(getFullPath(folderName)); triggerBrowserDownload(blob, folderName + '.zip'); } 
            catch(error) { await showAlert(`Export failed: ${error.message}`); } finally { setBusyState(false); }
        }
        
        let closeMediaViewer;
        async function showMediaViewer(name) {
            try {
                setBusyState(true, `Loading media...`, true); const blob = await fullDownload(getFullPath(name)); const url = URL.createObjectURL(blob);
                ui.mediaContent.innerHTML = ''; ui.mediaControls.innerHTML = '';
                const isImage = VIEWABLE_TYPES.image.test(name); const isAudio = VIEWABLE_TYPES.audio.test(name);
                closeMediaViewer = () => {
                    const media = ui.mediaContent.querySelector('img, video, audio');
                    if (media) { if (typeof media.pause === 'function') media.pause(); URL.revokeObjectURL(media.src); }
                    ui.mediaContent.innerHTML = ''; ui.mediaViewer.style.display = 'none';
                };
                if (isImage) {
                    ui.mediaContent.innerHTML = '<div id="image-box"><img></div>'; const img = ui.mediaContent.querySelector('img'); img.src = url;
                    let zoom = 1, isDragging = false; let start = { x: 0, y: 0 }, translate = { x: 0, y: 0 };
                    const updateTransform = () => { img.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${zoom})`; };
                    const onMouseDown = e => { e.preventDefault(); isDragging = true; start = { x: e.clientX - translate.x, y: e.clientY - translate.y }; img.style.cursor = 'grabbing'; img.style.transition = 'none'; };
                    const onMouseMove = e => { if (!isDragging) return; e.preventDefault(); translate.x = e.clientX - start.x; translate.y = e.clientY - start.y; updateTransform(); };
                    const onMouseUp = () => { isDragging = false; img.style.cursor = 'grab'; img.style.transition = 'transform 0.2s ease-out'; };
                    img.addEventListener('mousedown', onMouseDown); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp);
                    ui.mediaControls.innerHTML = `<button id="zoom-out-btn">-</button><button id="zoom-reset-btn">Reset</button><button id="zoom-in-btn">+</button><button id="media-download-btn">Download</button><button id="media-close-btn">Close</button>`;
                    document.getElementById('zoom-in-btn').onclick = () => { zoom *= 1.2; updateTransform(); }; document.getElementById('zoom-out-btn').onclick = () => { zoom /= 1.2; updateTransform(); }; document.getElementById('zoom-reset-btn').onclick = () => { zoom = 1; translate = {x: 0, y: 0}; updateTransform(); };
                    const originalClose = closeMediaViewer;
                    closeMediaViewer = () => { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); originalClose(); };
                } else if (isAudio) {
                    const audio = document.createElement('audio'); audio.controls = true; audio.src = url; ui.mediaContent.appendChild(audio);
                    ui.mediaControls.innerHTML = `<button id="media-download-btn">Download</button><button id="media-close-btn">Close</button>`;
                } else { const video = document.createElement('video'); video.controls = true; video.src = url; ui.mediaContent.appendChild(video); ui.mediaControls.innerHTML = `<button id="media-download-btn">Download</button><button id="media-close-btn">Close</button>`; }
                document.getElementById('media-download-btn').onclick = () => triggerBrowserDownload(blob, name); document.getElementById('media-close-btn').onclick = () => closeMediaViewer();
                ui.mediaViewer.style.display = 'flex';
            } catch(e) { await showAlert(`Could not load media: ${e.message}`); } finally { setBusyState(false); }
        }
        
        function applyNodeChanges() { ui.changeNodesModal.style.display = 'none'; currentPath = "/"; updateCurrentPathDisplay(); listDirectoryContents(); }

        async function createNewFolder() {
            const folderName = await showPrompt("Enter the name for the new folder:");
            if (!folderName || folderName.trim() === '') return;
            if (/[\\/:*?"<>|]/.test(folderName)) { await showAlert("Folder name contains invalid characters."); return; }
            const newFolderPath = getFullPath(folderName.trim());
            try { setBusyState(true, `Creating folder "${folderName}"...`); await runCommand('newfolder', [newFolderPath]); listDirectoryContents(); } 
            catch (error) { await showAlert(`Could not create folder: ${error.message}`); } finally { setBusyState(false); }
        }

        async function initiateUpload(uploaderElement) {
            if (connectedHosts.size <= 1) { uploaderElement.targetHostId = connectedHosts.values().next().value; uploaderElement.click(); } 
            else {
                ui.uploadNodeList.innerHTML = ''; const connectedHostArray = Array.from(connectedHosts); const randomIndex = Math.floor(Math.random() * connectedHostArray.length);
                const defaultHostId = connectedHostArray[randomIndex];
                connectedHostArray.forEach(hostId => {
                    const hostname = hostDetails.get(hostId) || hostId; const isChecked = (hostId === defaultHostId) ? 'checked' : '';
                    const radioHtml = `<label><input type="radio" name="upload-target" value="${hostId}" ${isChecked}> ${hostname}</label>`;
                    ui.uploadNodeList.insertAdjacentHTML('beforeend', radioHtml);
                });
                ui.confirmUploadTargetBtn.onclick = async () => {
                    const selectedHostInput = ui.uploadNodeList.querySelector('input[name="upload-target"]:checked');
                    if (selectedHostInput) { ui.uploadTargetModal.style.display = 'none'; uploaderElement.targetHostId = selectedHostInput.value; uploaderElement.click(); } 
                    else { await showAlert('Please select a node to upload to.'); }
                };
                ui.uploadTargetModal.style.display = 'flex';
            }
        }
        
        async function handleUpload(files, targetHostId) {
            if (!files.length) return;
            try {
                for (const file of files) {
                    const fullPath = getFullPath(file.webkitRelativePath || file.name);
                    setBusyState(true, `Uploading ${file.name} to ${hostDetails.get(targetHostId)}...`, true);
                    const numChunks = Math.ceil(file.size / UPLOAD_CHUNK_SIZE);
                    if (numChunks === 0) { await runCommand('setfile', [fullPath, ''], { targetHostId }); continue; }
                    for (let i = 0; i < numChunks; i++) {
                        updateProgress(i, numChunks);
                        const chunkBlob = file.slice(i * UPLOAD_CHUNK_SIZE, (i + 1) * UPLOAD_CHUNK_SIZE);
                        const b64Chunk = await blobToBase64(chunkBlob);
                        const command = (i === 0) ? 'setfile' : 'appendfile';
                        await runCommandWithRetry(command, [fullPath, b64Chunk], { targetHostId });
                    }
                }
                listDirectoryContents();
            } catch(error) { await showAlert(`Upload failed: ${error.message}`); }
            finally { setBusyState(false); ui.fileUploader.value = ''; ui.folderUploader.value = ''; }
        }
        
        function setBusyState(busy, text = 'Processing...', showProgress = false) { isBusy = busy; ui.loaderText.textContent = text; ui.progressContainer.style.display = showProgress ? 'block' : 'none'; if (!busy) updateProgress(0, 1); ui.loader.style.display = busy ? 'flex' : 'none'; document.querySelectorAll('button').forEach(b => b.disabled = busy); }
        function updateProgress(current, total) { const pct = total > 0 ? Math.round((current / total) * 100) : 0; ui.progressBar.style.width = `${pct}%`; }
        function blobToBase64(blob) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => resolve(reader.result.split(',')[1]); reader.onerror = reject; reader.readAsDataURL(blob); }); }
        function triggerBrowserDownload(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = filename; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove(); }
        function updateCurrentPathDisplay() { ui.currentPathDisplay.textContent = currentPath; }
        function getFullPath(name) { return (currentPath === "/") ? `/${name}` : `${currentPath}/${name}`; }
        function navigateTo(folderName) { currentPath = getFullPath(folderName); updateCurrentPathDisplay(); listDirectoryContents(); }
        function goUp() { if (currentPath === "/") return; currentPath = "/" + currentPath.split('/').filter(p => p).slice(0, -1).join('/'); updateCurrentPathDisplay(); listDirectoryContents(); }
    </script></body>
</html>
